# -*- coding: utf-8 -*-
"""train_models.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1OV5XDR9JLwUUVEv8fY1y1eTpDPl4tJ0G
"""

#!pip install dnspython

import numpy as np
import matplotlib.pyplot as plt
import pandas as pd
import tensorflow as tf
import keras
import pymongo
import datetime
import pickle
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler

PASSWORD = '#######'

CRYPTO_LIST = { 'bitcoin': 'BTC-USD', 'dash' : 'DASH-USD', 'ethereum' : 'ETH-USD', 'litecoin' : 'LTC-USD', 'monero' : 'XMR-USD',
                'ripple' : 'XRP-USD' }

FOREX_LIST = { 'AustralianDollar' : 'AUDUSD=X', 'Euro' : 'EURUSD=X', 'NewZealandDollar' : 'NZDUSD=X', 'BritishPound' : 'GBPUSD=X', 
              'BrazilianReal' : 'BRLUSD=X', 'CanadianDollar' : 'CADUSD=X', 'ChineseYuan' : 'CNYUSD=X', 'HongKongDollar' : 'HKDUSD=X', 
              'IndianRupee' : 'INRUSD=X', 'KoreanWon' : 'KRWUSD=X', 'MexicanPeso' : 'MXNUSD=X', 'SouthAfricanRand' : 'ZARUSD=X', 
              'SingaporeDollar' : 'SGDUSD=X', 'DanishKrone' : 'DKKUSD=X', 'JapaneseYen' : 'JPYUSD=X', 'MalaysianRinggit' : 'MYRUSD=X', 
              'NorwegianKrone' : 'NOKUSD=X', 'SwedishKrona' : 'SEKUSD=X', 'SriLankanRupee' : 'LKRUSD=X', 'SwissFranc' : 'CHFUSD=X', 
              'NewTaiwanDollar' : 'TWDUSD=X', 'ThaiBaht' : 'THBUSD=X' }

STOCK_INDICES = { 'S&P500' : '^GSPC', 'Dow30' : '^DJI', 'NASDAQ' : '^IXIC', 'Russel2000' : '^RUT', 'S&P/TSX' : '^GSPTSE', 
                  'IBOVESPA' : '^BVSP', 'IPCMEXICO' : '^MXX', 'Nikkei225' : '^N225', 'HANGSENGINDEX' : '^HSI', 
                  'SSE' : '000001.SS', 'ShenzhenComponent' : '399001.SZ', 'TSEC' : '^TWII', 'KOSPI' : '^KS11', 'STI' : '^STI', 
                  'Jakarta' : '^JKSE', 'FTSEBursaMalaysiaKLCI' : '^KLSE', 'S&P/ASX200' : '^AXJO',  'S&P/NZX50' : '^NZ50', 
                  'S&PBSE' : '^BSESN', 'FTSE100' : '^FTSE', 'DAX' : '^GDAXI', 'CAC40' : '^FCHI', 
                  'ESTX50' : '^STOXX50E', 'EURONEXT100' : '^N100', 'BEL 20' : '^BFX' }

nn_data_columns = ['bitcoin', 'dash', 'ethereum', 'litecoin', 'monero', 'ripple', 'AustralianDollar', 'Euro', 'NewZealandDollar', 
                   'BritishPound', 'BrazilianReal', 'CanadianDollar', 'ChineseYuan', 'HongKongDollar', 'IndianRupee', 'KoreanWon', 
                   'MexicanPeso', 'SouthAfricanRand', 'SingaporeDollar', 'DanishKrone', 'JapaneseYen', 'MalaysianRinggit', 
                   'NorwegianKrone', 'SwedishKrona', 'SriLankanRupee', 'SwissFranc', 'NewTaiwanDollar', 'ThaiBaht', 'S&P500', 
                   'Dow30', 'NASDAQ', 'Russel2000', 'S&P/TSX', 'IBOVESPA', 'IPCMEXICO', 'Nikkei225', 'HANGSENGINDEX', 
                   'SSE', 'ShenzhenComponent', 'TSEC', 'KOSPI', 'STI', 'Jakarta', 'FTSEBursaMalaysiaKLCI', 'S&P/ASX200', 'S&P/NZX50', 
                   'S&PBSE', 'FTSE100', 'DAX', 'CAC40', 'ESTX50', 'EURONEXT100', 'BEL 20']

def get_nn_data():
  client = pymongo.MongoClient("mongodb+srv://kmhatre:" + PASSWORD + "@crypto.j5hw0.mongodb.net/" + 'nn_data' + "?retryWrites=true&w=majority")
  db = client['nn_data']
  col = db['nn_data']
  result = []
  for x in col.find():
    result.append(x)
  df = pd.DataFrame(result)
  df = df.drop(['_id'], axis=1)  	
  return df

df = get_nn_data()

def create_model(X_train, y_train):
  input_shape = len(X_train[0])
  output_shape = len(y_train[0])
  model = keras.models.Sequential()
  model.add(keras.layers.Dense(units=8, activation='relu', kernel_initializer='normal', input_dim=input_shape))
  model.add(keras.layers.Dense(units=2670, activation='relu'))
  model.add(keras.layers.Dense(units=output_shape, activation='linear'))
  return model

def train_model(df):
  x_cols = list(STOCK_INDICES.keys()) + list(FOREX_LIST.keys())
  y_cols = list(CRYPTO_LIST.keys())
  X = df[x_cols].to_numpy(dtype=np.float32)[1:] # FOR PREDICTIONS BASED ON PREVIOUS DAY'S STOCK INDICES AND FOREX RATES
  Y = df[y_cols].to_numpy(dtype=np.float32)[:-1] # FOR PREDICTIONS BASED ON PREVIOUS DAY'S STOCK INDICES AND FOREX RATES
  x_normalizer = StandardScaler()
  x_normalizer.fit(np.array(X, dtype=np.float32))
  y_normalizer = StandardScaler()
  y_normalizer.fit(np.array(Y, dtype=np.float32))

  norm_path = '/Normalizers/'
  with open(norm_path + 'x_norm.pkl', 'wb') as f:
    pickle.dump(x_normalizer, f, protocol=pickle.HIGHEST_PROTOCOL)
  with open(norm_path + 'y_norm.pkl', 'wb') as f:
    pickle.dump(y_normalizer, f, protocol=pickle.HIGHEST_PROTOCOL)

  x_data = np.array(x_normalizer.transform(X))
  y_data = np.array(y_normalizer.transform(Y))
  X_train, X_test, y_train, y_test = train_test_split(x_data, y_data, test_size=0.06, shuffle=True, random_state=42)  
  model = create_model(X_train, y_train)
  model.compile(
    optimizer='adam',
    loss='mean_squared_error', metrics=['mse'])
  model.fit(X_train, y_train, epochs=2000, validation_split=0.2)
  model_path = '/Models/model.h5'
  model.save(model_path)
  print('Model Saved')

train_model(df)